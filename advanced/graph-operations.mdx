---
title: "Advanced Graph Operations"
sidebarTitle: "Graph Operations"
description: "Explore advanced techniques for manipulating and optimizing SmartGraph structures"
icon: "network-wired"
---

This guide covers advanced graph operations in SmartGraph, allowing you to create more dynamic, efficient, and complex workflows. We'll explore techniques for runtime graph modifications, advanced routing strategies, and working with subgraphs.

## Dynamic Graph Modifications

SmartGraph allows you to modify the graph structure at runtime, enabling adaptive workflows that change based on execution results or external factors.

### Adding Nodes and Edges Dynamically

You can add new nodes and edges to your graph during execution:

```python
class DynamicGraphActor(BaseActor):
    async def perform_task(self, task, input_data, state):
        if task.description == "expand_graph":
            new_node = Node(id="dynamic_node", actor=self, task=Task(description="Dynamic task"))
            self.graph.add_node(new_node)
            self.graph.add_edge(Edge(source_id=self.current_node_id, target_id="dynamic_node"))
            return {"status": "Graph expanded"}
        return await super().perform_task(task, input_data, state)

dynamic_actor = DynamicGraphActor("DynamicActor")
expand_node = Node(id="expand", actor=dynamic_actor, task=Task(description="expand_graph"))
graph.add_node(expand_node)
```

### Removing Nodes and Edges

You can also remove nodes and edges based on certain conditions:

```python
class PruningActor(BaseActor):
    async def perform_task(self, task, input_data, state):
        if task.description == "prune_graph":
            nodes_to_remove = [node for node in self.graph.nodes if some_condition(node)]
            for node in nodes_to_remove:
                self.graph.remove_node(node.id)
            return {"status": "Graph pruned"}
        return await super().perform_task(task, input_data, state)
```

## Advanced Routing Strategies

SmartGraph supports complex routing strategies that go beyond simple conditional edges.

### Multi-Condition Routing

You can use multiple conditions to determine the next node:

```python
def complex_condition(data):
    return (data.get('value', 0) > 10 and
            data.get('status') == 'approved' and
            'error' not in data)

graph.add_edge(Edge(source_id="process", target_id="advanced_process", condition=complex_condition))
graph.add_edge(Edge(source_id="process", target_id="simple_process", condition=lambda data: not complex_condition(data)))
```

### Weighted Random Routing

Implement a weighted random routing strategy for A/B testing or load balancing:

```python
import random

def weighted_random_route(data):
    weights = {'nodeA': 0.7, 'nodeB': 0.2, 'nodeC': 0.1}
    return random.choices(list(weights.keys()), weights=list(weights.values()))[0]

decision_node = Node(id="decision", actor=DecisionActor(), task=Task(description="Route randomly"))
for target in ['nodeA', 'nodeB', 'nodeC']:
    graph.add_edge(Edge(source_id="decision", target_id=target, condition=lambda data, t=target: weighted_random_route(data) == t))
```

## Working with Subgraphs

SmartGraph allows you to work with subgraphs, enabling modular design and reusable components.

### Creating Subgraphs

Define a subgraph that can be reused in different parts of your main graph:

```python
def create_processing_subgraph(prefix):
    subgraph = SmartGraph()

    input_node = Node(id=f"{prefix}_input", actor=InputActor(), task=Task(description="Get input"))
    process_node = Node(id=f"{prefix}_process", actor=ProcessActor(), task=Task(description="Process data"))
    output_node = Node(id=f"{prefix}_output", actor=OutputActor(), task=Task(description="Produce output"))

    subgraph.add_node(input_node)
    subgraph.add_node(process_node)
    subgraph.add_node(output_node)

    subgraph.add_edge(Edge(source_id=f"{prefix}_input", target_id=f"{prefix}_process"))
    subgraph.add_edge(Edge(source_id=f"{prefix}_process", target_id=f"{prefix}_output"))

    return subgraph

main_graph = SmartGraph()
subgraph_a = create_processing_subgraph("a")
subgraph_b = create_processing_subgraph("b")

main_graph.merge_subgraph(subgraph_a)
main_graph.merge_subgraph(subgraph_b)

main_graph.add_edge(Edge(source_id="a_output", target_id="b_input"))
```

### Conditional Subgraph Execution

Execute entire subgraphs conditionally based on runtime data:

```python
class SubgraphActor(BaseActor):
    def __init__(self, name, subgraph):
        super().__init__(name)
        self.subgraph = subgraph

    async def perform_task(self, task, input_data, state):
        if task.description == "execute_subgraph":
            subgraph_result = await self.subgraph.execute(self.subgraph.start_node_id, input_data, f"subgraph_{self.name}")
            return {"subgraph_result": subgraph_result}
        return await super().perform_task(task, input_data, state)

subgraph_actor = SubgraphActor("SubgraphA", create_processing_subgraph("sub"))
conditional_node = Node(id="conditional_subgraph", actor=subgraph_actor, task=Task(description="execute_subgraph"))
graph.add_node(conditional_node)
```

## Advanced Graph Analysis

Leverage NetworkX's capabilities for advanced graph analysis within SmartGraph:

```python
import networkx as nx

class GraphAnalysisActor(BaseActor):
    async def perform_task(self, task, input_data, state):
        if task.description == "analyze_graph":
            # Convert SmartGraph to NetworkX graph
            nx_graph = self.graph.to_networkx()

            # Perform advanced analysis
            centrality = nx.betweenness_centrality(nx_graph)
            communities = list(nx.community.greedy_modularity_communities(nx_graph))
            shortest_path = nx.shortest_path(nx_graph, source="start_node", target="end_node")

            return {
                "centrality": centrality,
                "communities": communities,
                "shortest_path": shortest_path
            }
        return await super().perform_task(task, input_data, state)

analysis_node = Node(id="graph_analysis", actor=GraphAnalysisActor(), task=Task(description="analyze_graph"))
graph.add_node(analysis_node)
```

## Conclusion

These advanced graph operations allow you to create highly dynamic, efficient, and complex workflows in SmartGraph. By leveraging these techniques, you can build adaptive AI systems that can modify their behavior and structure based on runtime conditions and analysis results.

Remember to handle errors and edge cases when working with dynamic graph modifications, and always ensure that your graph remains in a valid state after operations.

As SmartGraph continues to evolve, even more advanced graph manipulation features may become available, enabling even more sophisticated AI-driven applications.
